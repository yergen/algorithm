一棵B树T是具有以下性质的有根数（根为T.root）
1.每个结点x有下面属性：
 a. x.n,当前存储在结点x中的关键字个数。
 b. x.n个关键字本身x.key1,x.key2, ..., x.key(n),以非降序存放，使得x.key1 <= x.key2
   <= ... <= x.key(n)。
 c. x.leaf, 一个布尔值， 如果x是叶节点，则为TRUE; 如果x为内部结点，则为FALSE。
2.每个内部结点x还包含x.n+1个指向其孩子的指针x.c1,x.c2, ..., x.c(n+1)。页结点没有孩子，所以他们的ci属性没有定义。
3.关键字x.key(i)对存储在各个子树的关键字范围加以分割：如果k(i)为任意一个存储在以x.c(i)为根的子树中的关键字，那么
	k1<=x.key1<=k2<=x.key2<=...<=x.key(n)<=x.key(n+1)
4.每个叶节点具有相同的深度，即树的高度h.
5.每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数(minimum degree)的固定整数t>=2来表示这些界:
 a.除了根结点以外的每个结点至少有t-1个关键字。因此，除了根结点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字。
 b.每个结点至多可包含2t-1个关键字。因此，一个内部结点至多可有2t个孩子。当一个结点恰好有2t-1个关键字时，称该结点是满的（full）。
 t=2时的B树是最简单的。每个内部结点有2个、3个、或4个孩子，即一棵2-3-4树。然而在实际中，t的值越大，B树的高度就越小。

定理1：如果n>=1,那么对任意一棵包含n个关键字、高度为h、最小度数t>=2的B树T，有
	h <= log(t) ((n+1)/2)

两个约定：
1.B树的根结点始终在主存中，这样无需对根做DISK-READ操作；然而，当根结点被改动后，需要对根结点做一次DISK-WRITE操作。
2.任何被当做参数的结点在被传递之前，都要对它们先做一次DISK-READ操作。

分裂是树长高的唯一途径。

删除函数有问题！
